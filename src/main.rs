mod tests;
mod order_service;
mod order_service_tests;

extern crate rocket;

extern crate fern;
#[macro_use]
extern crate log;

extern crate chrono;

use std::collections::HashMap;
use std::sync::{Arc, Once, RwLock};
use std::error::Error;
use std::fmt;
use std::env; // Added to read environment variables
use rocket::{delete, get, launch, put, routes, Build, State};
use rocket::http::Status;
use rocket::serde::{Deserialize, Serialize};
use rocket::serde::json::{json, Json};
use rocket::serde::json::Error as JsonError;
use rand::Rng;
use rocket::figment::Figment;
use order_service::{InMemoryOrderService, OrderService, OrderServiceError};
use crate::order_service::{Order, OrderResult};

#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "rocket::serde")]
pub struct CreateOrder {
    item_id: String,
    table_id: String,
}

#[derive(Serialize, Clone, Deserialize, Debug)]
#[serde(crate = "rocket::serde")]
pub struct OrderDetails {
    order_id: String,
    item_id: String,
    table_id: String,
    cooking_time: i32,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "rocket::serde")]
pub struct ErrorResponse {
    error: String,
    error_code: String,
}

// PUT /order/<id> is a simple idempotent way of adding new Orders into the system.
// Each Order represents a concrete item ordered at the specific table and has unique UUID4,
// generated by the client ("id"). Upon order acceptance, a cooking time is assigned to it.
// Cooking time value depends on current kitchen load.
//
// Usage of UUID4 is necessary to avoid duplicates or overrides in case of poor network, since
// we don't want the same order to be submitted twice or an existing order to be overwritten
// by its own copy with a different cooking time.
//
// There is chance that two waiters' devices would generate the same UUID4, but
// the chance is practically negligible. Considering the "cost" of such error, this is no-issue.
//
// PUT /order/<id> may return:
// Status: 200, Body: details of newly accepted order
// Status: 400, Body: error description, error code (in case of malformed request body)
// Status: 409, Body: error description, error code (in case Order with such id already exists)
// Status: 500, Body: error description, error code
#[put("/<id>", format = "json", data = "<order>")]
fn put_order(
    id: String,
    order: Result<Json<CreateOrder>, JsonError<'_>>,
    order_service: &State<Arc<dyn OrderService>>,
) -> Result<Json<OrderDetails>, (Status, Json<ErrorResponse>)> {
    let order = match order {
        Ok(order) => order.into_inner(),
        Err(e) => {
            error!("Failed to parse JSON body: {}", e);
            return Err((
                Status::BadRequest,
                Json(ErrorResponse {
                    error: "Invalid request body".to_string(),
                    error_code: "INVALID_BODY".to_string(),
                }),
            ));
        }
    };

    let res = order_service.put_order(id.clone(), Order {
        item_id: order.item_id,
        table_id: order.table_id,
    });

    match res {
        Ok(order_result) => Ok(Json(OrderDetails {
            order_id: order_result.order_id,
            item_id: order_result.item_id,
            table_id: order_result.table_id,
            cooking_time: order_result.cooking_time,
        })),
        Err(OrderServiceError::DuplicateOrder(_)) => Err((
            Status::Conflict,
            Json(ErrorResponse {
                error: "Order already exists".to_string(),
                error_code: "DUPLICATE_ORDER".to_string(),
            }),
        )),
        Err(e) => {
            error!("{}", e);
            Err((
                Status::InternalServerError,
                Json(ErrorResponse {
                    error: "Internal server error".to_string(),
                    error_code: "INTERNAL_ERROR".to_string(),
                }),
            ))
        }
    }
}

// GET /orders?table_id=...&item_id=... provides a filtered list of orders.
// The filtering logic:
// table_id + item_id: all orders with given item for the specified table
// table_id: all orders for the given table
// item_id: all orders with the given item
// <no params>: all orders in the system
// (Note: for production system we would implement pagination with reasonable default params)

// GET /orders?table_id=...&item_id=... may return:
// Status: 200, Body: array of orders' details
// Status: 500, Body: error description, error code
#[get("/?<table_id>&<item_id>")]
fn get_order(
    table_id: Option<String>,
    item_id: Option<String>,
    order_service: &State<Arc<dyn OrderService>>,
) -> Result<Json<Vec<OrderDetails>>, (Status, Json<ErrorResponse>)> {
    let res = order_service
        .inner()
        .get_orders(table_id.clone(), item_id.clone());

    match res {
        Ok(orders) => {
            let order_details: Vec<OrderDetails> = orders.into_iter().map(|order| OrderDetails {
                order_id: order.order_id,
                item_id: order.item_id,
                table_id: order.table_id,
                cooking_time: order.cooking_time,
            }).collect();

            Ok(Json(order_details))
        },
        Err(e) => {
            error!("{}", e);
            Err((
                Status::InternalServerError,
                Json(ErrorResponse {
                    error: "Internal server error".to_string(),
                    error_code: "INTERNAL_ERROR".to_string(),
                }),
            ))
        }
    }
}

// DELETE /order/<id> either deletes an order or returns a 404 if such order does not exist.
// Status: 200
// Status: 404, Body:error description, error code
// Status: 500, Body: error description, error code
#[delete("/<id>")]
fn delete_order(
    id: String,
    order_service: &State<Arc<dyn OrderService>>,
) -> Result<Status, (Status, Json<ErrorResponse>)> {
    let res = order_service.inner().delete_order(id.clone());
    match res {
        Ok(_) => Ok(Status::Ok),
        Err(OrderServiceError::OrderNotFound(_)) => Err((
            Status::NotFound,
            Json(ErrorResponse {
                error: "Order not found".to_string(),
                error_code: "ORDER_NOT_FOUND".to_string(),
            }),
        )),
        Err(e) => {
            error!("{}", e);
            Err((
                Status::InternalServerError,
                Json(ErrorResponse {
                    error: "Internal server error".to_string(),
                    error_code: "INTERNAL_ERROR".to_string(),
                }),
            ))
        }
    }
}

#[launch]
fn rocket() -> _ {
    create_rocket()
}

fn create_rocket() -> rocket::Rocket<Build> {
    static START: Once = Once::new();
    START.call_once(|| {
        setup_logger().unwrap();
    });


    let port: u16 = env::var("APP_PORT")
        .unwrap_or_else(|_| "8000".to_string())
        .parse()
        .expect("APP_PORT must be a valid u16 integer");

    let workers: usize = env::var("APP_NUM_THREADS")
        .unwrap_or_else(|_| "10".to_string())
        .parse()
        .expect("APP_NUM_THREADS must be a valid usize integer");

    let figment = Figment::from(rocket::Config::default())
        .merge(("port", port))
        .merge(("workers", workers));

    // Using rocket's Request Guard we could implement an authentication middleware which
    // would be applied to all requests. Such middleware could verify Authorization header with
    // access tokens send by restaurant's staff devices and "bounce back" requests without
    // valid authentication, possibly prompting them to obtain a valid token.
    //
    // In a similar manner an authorization middleware could be implemented. Based on access token
    // contents and request's params (path, method, params) such middleware could either allow
    // or forbid the request.
    rocket::custom(figment)
        .manage(Arc::new(order_service::new_in_memory()) as Arc<dyn OrderService>)
        .mount("/order", routes![put_order, delete_order])
        .mount("/orders", routes![get_order])
}

fn setup_logger() -> Result<(), fern::InitError> {
    fern::Dispatch::new()
        .format(|out, message, record| {
            out.finish(format_args!(
                "{}[{}][{}] {}",
                chrono::Local::now().format("[%Y-%m-%d][%H:%M:%S]"),
                record.target(),
                record.level(),
                message
            ))
        })
        .level(log::LevelFilter::Debug)
        .chain(std::io::stdout())
        .apply()?;
    Ok(())
}
